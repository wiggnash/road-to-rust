Rust is **Statically typed language** => it must know the types of all variables at complie time. Every value in RUST is a data type , which makes the complier to make it easy to work with that data

Complier will be able to tell what is the type of the data that we are using 
## Types of Data 
1. Scalar : Represents single value
	1. Integers
	2. Floating Point
	3. Numbers
	4. Booleans
	5. Characters
2. Compound : can group multiple values in one type
	1. Tuples 
	2. Arrays

# Scalar Values

## Integers : Number without fraction
---
Integers can be both positive and negative , therfore it has two types. Takes 32 bits of space by default and its better to use the same at most of the cases
1. *Signed Integers ( i )* : Both positive and negative numbers  : Value range => -(2 ^ n - 1) to 2 ^ n - 1 - 1 **inclusive** and n is the number of bits
2. *Unsigned Integers ( u )* : Only positive numbers : Value range => 0 to 2 ^ n - 1

![[Pasted image 20241022234947.png]]
### How can signed numbers stored ?

Signed numbers are stored in the 2's Complement representation


### Size of the Integers 

- Depends on the architecuture of the computer in which the program is running
- 32bit Arch or 64bit Arch


### Integer Overflow and Panicking

- When the value of the integer goes out of the range, this is called overflow 
- Because of this RUST panics : Happens during the complie time and **debug mode** , Where RUST checks for the integer overflow , therefore it exists with an error 

**What happens in the release mode ?**

- No integer overflow checks , but it does 2's complement wrapper
- When the value goes out to of the range , it will assign it to the lowest value of that type

**Therefore we need to handle the overflow condition correctly instead of this way**
- Wrap all modes with the *wrapping function*
- Return None with *checked method*
- Return the value and with a boolean indicating overflow happened

## [Floating-Point Types](https://doc.rust-lang.org/book/ch03-02-data-types.html#floating-point-types)

- These are decimal numbers and it has two types 32 and 64 bits
- Default is 64 bits , which is double precision floating number
- 32 bits gives precision => this is single precision floating number
- All the floating point numbers are signed 

## [The Boolean Type](https://doc.rust-lang.org/book/ch03-02-data-types.html#the-boolean-type)

True or False
what is the size of Boolean : 1 byte : 8 bits

use booleans in conditionals


## [The Character Type](https://doc.rust-lang.org/book/ch03-02-data-types.html#the-character-type)

- This is the most basic alphabet type
- it is written in **character : single quotes**
- **strings : double quotes**
- Size of a character : 4 bytes in size and represents a unicode scalar value
- According to RUST character is not there , but we have kept it like this